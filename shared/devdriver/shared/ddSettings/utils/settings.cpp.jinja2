/* Copyright (c) 2022-2023 Advanced Micro Devices, Inc. All rights reserved. */

// =============================================================================
// WARNING!  WARNING!  WARNING!  WARNING!  WARNING!  WARNING!  WARNING!
//
// This code was auto-generated by settings_codegen.py. Do not modify manually.
// =============================================================================

#include "{{codeGenHeader}}"
#include <{{settingsHeader}}>

#include <devDriverServer.h>
#include <protocols/ddSettingsService.h>
{% if UseRpc %}
#include <ddSettingsService.h>
{% endif %}
#include <ddSettingsTypes.h>

{% if palSettings %}
#include "palInlineFuncs.h"
#include "core/device.h"
{% endif %}

using namespace DevDriver::SettingsURIService;

{% macro prep_cond_begin(prep_cond) %}
{% if prep_cond %}
{{prep_cond|buildtypes_to_c_macro}}
{% endif %}
{% endmacro %}
{# ======================================== #}
{% macro prep_cond_end(prep_cond) %}
{% if prep_cond %}
#endif

{% endif %}
{% endmacro %}

namespace {{namespace}}
{

// =======================================================================================
const char* {{className}}::GetComponentName() const
{
    return "{{component}}";
}

// =======================================================================================
uint64_t {{className}}::GetComponentHash() const
{
    return (uint64_t){{settingsBlobHash|abs}}ULL;
}

// =======================================================================================
// Initializes the settings structure to default values.
void {{className}}::SetupDefaults()
{
{% for setting in settings %}
{% if setting.groupName %}

{% for subs in setting.subsettings %}
{{ prep_cond_begin(subs.buildtypes) -}}
{{ subs|setup_default(setting.groupVariableName) -}}
{{ prep_cond_end(subs.buildtypes) -}}
{% endfor %}
{% else %}
{{ prep_cond_begin(setting.buildtypes) -}}
{{ setting|setup_default('') -}}
{{ prep_cond_end(setting.buildtypes) -}}
{% endif %}
{% endfor %}
}

// =======================================================================================
// Initializes the SettingInfo hash map and array of setting hashes.
void {{className}}::InitSettingsInfo()
{
    using namespace DevDriver;

    DDSettingsValueRef valueRef = {};
{% for setting in settings %}
{% if setting.groupName %}

{% for subs in setting.subsettings %}
{{ prep_cond_begin(subs.buildtypes) }}
    valueRef.type = {{ subs.defaults.type|setting_type_cpp }};
    valueRef.pVal = &m_settings.{{setting.groupVariableName}}.{{subs.variableName}};
    valueRef.size = sizeof(m_settings.{{setting.groupVariableName}}.{{subs.variableName}});
    m_settingsMap.Insert({{subs.nameHash}}, valueRef);
{{ prep_cond_end(subs.buildtypes) -}}
{% endfor %}
{% else %}
{{ prep_cond_begin(setting.buildtypes) }}
    valueRef.type = {{ setting.defaults.type|setting_type_cpp }};
    valueRef.pVal = &m_settings.{{setting.variableName}};
    valueRef.size = sizeof(m_settings.{{setting.variableName}});
    m_settingsMap.Insert({{setting.nameHash}}, valueRef);
{{ prep_cond_end(setting.buildtypes) -}}
{% endif %}
{% endfor %}
}

{% if palSettings %}
// =======================================================================================
// Read settings from registry for PAL settings.
void {{className}}::ReadSettings(Pal::Device* pDevice)
{
{% for setting in settings %}
{% if setting.groupName %}

{% for subs in setting.subsettings %}
{{ prep_cond_begin(subs.buildtypes) }}
    pDevice->ReadSetting(
        p{{setting.groupName}}_{{subs.name}}HashStr,
        {{ subs.defaults.type|setting_type_cpp2 }},
        &m_settings.{{setting.groupVariableName}}.{{subs.variableName}},
        InternalSettingScope::{{setting.scope|default('PrivatePalKey')}});
{{ prep_cond_end(subs.buildtypes) -}}
{% endfor %}
{% else %}
{{ prep_cond_begin(setting.buildtypes) }}
    pDevice->ReadSetting(
        p{{setting.name}}HashStr,
        {{ setting.defaults.type|setting_type_cpp2 }},
        &m_settings.{{setting.variableName}},
        InternalSettingScope::{{setting.scope|default('PrivatePalKey')}});
{{ prep_cond_end(setting.buildtypes) -}}
{% endif %}
{% endfor %}
}
{% endif %}

{% if DxcSettings %}
// =======================================================================================
// Read settings from registry for DXCP settings.
void {{className}}::ReadSettings(DdiAdapter* pAdapter)
{
    (void)pAdapter;
}
{% endif %}

// =======================================================================================
// SettingsBlob implementation

const uint8_t* {{component}}SettingsBlobNode::GetBlob(uint32_t* pOutSize)
{
    static const uint8_t s_settingsBlob[] = {
        {{settingsBlob}}
    };

    static_assert({{settingsBlobSize}} == sizeof(s_settingsBlob),
        "Settings YAML data size in C++ doesn't match the one calculated "
        "in the codegen script."
    );

    *pOutSize = sizeof(s_settingsBlob);

    return s_settingsBlob;
}

bool {{component}}SettingsBlobNode::IsEncoded()
{
    return {{encoded|string|lower}};
}

uint64_t {{component}}SettingsBlobNode::GetBlobHash()
{
    return (uint64_t){{settingsBlobHash|abs}}ULL;
}

{{component}}SettingsBlobNode g_{{componentNameLower}}SettingsBlobNode;

} // namespace {{namespace}}
