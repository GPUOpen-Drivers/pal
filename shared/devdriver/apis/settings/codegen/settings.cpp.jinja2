/* Copyright (c) 2022-2023 Advanced Micro Devices, Inc. All rights reserved. */

// =============================================================================
// WARNING!  WARNING!  WARNING!  WARNING!  WARNING!  WARNING!  WARNING!
//
// This code was auto-generated by settings_codegen.py. Do not modify manually.
// =============================================================================

#include "{{CodeGenHeader}}"
#include <{{SettingsHeader}}>
#include <util/hashMap.h>

{% if palSettings %}
#include "core/device.h"
{% endif %}

{% macro prep_cond_begin(build_types, or_build_types) %}
{% if build_types or or_build_types %}
{{build_types|buildtypes_to_c_macro(or_build_types)}}
{% endif %}
{% endmacro %}
{# ======================================== #}
{% macro prep_cond_end(build_types, or_build_types) %}
{% if build_types or or_build_types %}
#endif

{% endif %}
{% endmacro %}

namespace {{Namespace}}
{

const char* {{ClassName}}::GetComponentName() const
{
    return "{{ComponentName}}";
}

// Initializes the settings hash map and array of setting hashes.
DD_RESULT {{ClassName}}::SetupDefaultsAndPopulateMap()
{
    DevDriver::Result result = DevDriver::Result::Success;

    DDSettingsValueRef valueRef = {};

{% for setting in Settings %}
{% if setting.Structure %}

{% for subs in setting.Structure %}
{{ prep_cond_begin(subs.BuildTypes, subs.OrBuildTypes) }}
    if (result == DevDriver::Result::Success)
    {
{{ subs|setup_default(setting.VariableName) }}
        valueRef.type = {{ subs.Type|setting_type_cpp }};
        valueRef.pValue = &m_settings.{{setting.VariableName}}.{{subs.VariableName}};
        valueRef.size = sizeof(m_settings.{{setting.VariableName}}.{{subs.VariableName}});
        valueRef.isOptional = {% if subs.IsOptional %}true{% else %}false{% endif %};
        result = m_settingsMap.Insert({{setting.VariableName}}_{{subs.VariableName}}Hash, valueRef);
    }
{{ prep_cond_end(subs.BuildTypes, subs.OrBuildTypes) -}}
{% endfor %}
{% else %}
{{ prep_cond_begin(setting.BuildTypes, setting.OrBuildTypes) }}
    if (result == DevDriver::Result::Success)
    {
{{ setting|setup_default('') }}
        valueRef.type = {{ setting.Type|setting_type_cpp }};
        valueRef.pValue = &m_settings.{{setting.VariableName}};
        valueRef.size = sizeof(m_settings.{{setting.VariableName}});
        valueRef.isOptional = {% if setting.IsOptional %}true{% else %}false{% endif %};
        result = m_settingsMap.Insert({{setting.VariableName}}Hash, valueRef);
    }
{{ prep_cond_end(setting.BuildTypes, setting.OrBuildTypes) -}}
{% endif %}
{% endfor %}

    return (result == DevDriver::Result::Success) ? DD_RESULT_SUCCESS : DD_RESULT_COMMON_OUT_OF_HEAP_MEMORY;
}

{% if IsPalSettings %}
// Read settings from registry for PAL settings.
void {{ClassName}}::ReadSettings(Pal::Device* pDevice)
{
{% for setting in Settings %}
{% if setting.Structure %}

{% for subs in setting.Structure %}
{{ prep_cond_begin(subs.BuildTypes, subs.OrBuildTypes) }}

{% if subs.IsOptional %}
    {
        {{subs.RawVariableType}} valueRead{};
        if (pDevice->ReadSetting(
            p{{setting.VariableName}}_{{subs.VariableName}}HashStr,
            {{ subs.Type|setting_type_cpp2 }},
            &valueRead,
            InternalSettingScope::{{setting.Scope|default('PrivatePalKey')}}{% if subs.StringLength %}, {{subs.StringLength}}{% endif %}))
        {
            m_settings.{{setting.VariableName}}.{{subs.VariableName}} = valueRead;
        }
    }
{% else %}
    pDevice->ReadSetting(
        p{{setting.VariableName}}_{{subs.VariableName}}HashStr,
        {{ subs.Type|setting_type_cpp2 }},
        &m_settings.{{setting.VariableName}}.{{subs.VariableName}},
        InternalSettingScope::{{setting.Scope|default('PrivatePalKey')}}{% if subs.StringLength %}, {{subs.StringLength}}{% endif %}))
{% endif %}
{{ prep_cond_end(subs.BuildTypes, subs.OrBuildTypes) -}}
{% endfor %}
{% else %}
{{ prep_cond_begin(setting.BuildTypes, setting.OrBuildTypes) }}
{% if setting.IsOptional %}
    {
        {{setting.RawVariableType}} valueRead{};
        if (pDevice->ReadSetting(
            p{{setting.Name}}HashStr,
            {{ setting.Type|setting_type_cpp2 }},
            &valueRead,
            InternalSettingScope::{{setting.scope|default('PrivatePalKey')}}{% if setting.StringLength %}, {{setting.StringLength}}{% endif %}))
        {
            m_settings.{{setting.VariableName}} = valueRead;
        }
    }
{% else %}
    pDevice->ReadSetting(
        p{{setting.Name}}HashStr,
        {{ setting.Type|setting_type_cpp2 }},
        m_settings.{{setting.VariableName}},
        InternalSettingScope::{{setting.scope|default('PrivatePalKey')}}{% if setting.StringLength %}, {{setting.StringLength}}{% endif %}))
{% endif %}
{{ prep_cond_end(setting.BuildTypes, setting.OrBuildTypes) -}}
{% endif %}
{% endfor %}
}
{% endif %}

{% if DxcSettings %}
// Read settings from registry for DXCP settings.
void {{className}}::ReadSettings(DdiAdapter* pAdapter)
{
    (void)pAdapter;
}
{% endif %}

// SettingsBlob implementation

{{ComponentName}}SettingsBlobNode g_{{ComponentNameLower}}SettingsBlobNode;

bool {{ComponentName}}SettingsBlobNode::IsEncoded()
{
    return {{IsEncoded|string|lower}};
}

uint32_t {{ComponentName}}SettingsBlobNode::GetMagicOffset()
{
    return {{MagicOffset}};
}

uint64_t {{ComponentName}}SettingsBlobNode::GetBlobHash()
{
    return static_cast<uint64_t>({{SettingsBlobHash|abs}}ULL);
}

const uint8_t* {{ComponentName}}SettingsBlobNode::GetBlob(uint32_t* pOutSize)
{
    static const uint8_t s_settingsBlob[] = {
        {{SettingsBlob}}
    };

    static_assert({{SettingsBlobSize}} == sizeof(s_settingsBlob),
        "Settings JSON data size in C++ doesn't match the one calculated "
        "in the codegen script."
    );

    *pOutSize = sizeof(s_settingsBlob);

    return s_settingsBlob;
}

} // namespace {{Namespace}}
